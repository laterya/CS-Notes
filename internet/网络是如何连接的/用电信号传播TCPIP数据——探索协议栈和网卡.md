## 创建套接字

### 协议栈的内部结构

TCP/IP软件采用分层结构

![image-20220511201313574](https://s2.loli.net/2022/05/11/6MIqhigD9JXvzVt.png)

上层会向下层逐层委派工作

-   浏览器、邮件等一般应用程序收发数据时用TCP;DNS查询等收发较短的控制数据时用UDP。

-   ICMP用于告知网络包传送过程中产生的错误以及各种控制消息，ARP用于根据IP地址查询相应的以太网MAC地址
-   IP下面的网卡驱动程序负责控制网卡硬件
-   最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。

### 套接字的实体就是通信控制信息

在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP地址、端口号、通信操作的进行状态等。本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。

协议栈是根据套接字中记录的控制信息来工作的。

显示套接字内容：

![image-20220511202159629](https://s2.loli.net/2022/05/11/lF2nBwWKSXrOJoC.png)

### 调用socket时的操作

1.   创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。

![image-20220511202529540](https://s2.loli.net/2022/05/11/NWCHbtGBDfrIdwq.png)

2.   接下来，需要将表示这个套接字的描述符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌
3.   收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。

## 连接服务器

### 连接是什么意思

-   创建套接字之后，应用程序（浏览器）就会调用connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。

-   **连接实际上是通信双方交换控制信息**，在套接字中记录这些必要信息并准备数据收发的一连串操作。例如把服务器的IP地址和端口号等信息告知协议栈，客户端向服务器传达开始通信的请求，等
-   当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的

### 负责保存控制信息的头部

通信操作中使用的控制信息分为两类。

1.   头部中记录的信息

控制信息位于网络包的开头，因此被称为头部。头部是用来记录和交换控制信息的

TCP头部格式：

![image-20220511203618528](https://s2.loli.net/2022/05/11/9hxMZQXz5VYjp8n.png)

![image-20220511203945194](https://s2.loli.net/2022/05/11/4WVbgcEtN7p1HIu.png)

2.   套接字（协议栈中的内存空间)中记录的信息

控制信息还有另外一类，那就是保存在套接字中，**用来控制协议栈操作的信息**

### 连接操作的实际过程

TCP连接三次握手？

从应用程序调用Socket库的connect开始的

>   connect (<描述符>, <服务器IP地址和端口号>, …)

-   上面的调用提供了服务器的IP地址和端口号，这些信息会传递给协议栈中的TCP模块。然后，TCP模块会与该IP地址对应的对象，也就是与服务器的TCP模块交换控制信息，
-   连接操作的第一步是在TCP模块处创建表示连接控制信息的头部。
-   通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字。
-   当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送,IP模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的IP模块会将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字，
-   当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接
-   服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特
-   在返回响应时还需要将ACK控制位设为1，这表示已经接收到相应的网络包。

## 收发数据

### 将HTTP请求消息交给协议栈

-   协议栈并不关心应用程序传来的数据是什么内容。
-   MTU：一个网络包的最大长度，以太网中一般为1500字节。MSS：除去头部之后，一个网络包所能容纳的TCP数据的最大长度。![image-20220513140723986](https://s2.loli.net/2022/05/13/xrUyOp9flvE8qaD.png)
-   协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。
    -   第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫作MTU的参数来进行判断。
    -   另一个判断要素是时间。协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去

### 对较大的数据进行拆分

-   当HTTP消息超过一个网络包所能容纳的数据量，发送缓冲区中的数据就会超过MSS的长度，这时我们当然不需要继续等待后面的数据了。发送缓冲区中的数据会**被以MSS长度为单位**进行拆分，拆分出来的每块数据会被放进**单独的**网络包中。
-   根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就在每一块数据前面加上TCP头部，并根据套接字中记录的控制信息标记发送方和接收方的端口号，然后交给IP模块来执行发送数据的操作

![image-20220513140935542](https://s2.loli.net/2022/05/13/U1rnL6lqwOVxj3u.png)

### 使用ACK号确认网络包已收到

![image-20220513141108959](https://s2.loli.net/2022/05/13/BtKMzAh728oTn1F.png)

-   TCP模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在TCP头部中，“序号”字段就是派在这个用场上的。
-   发送数据的长度也需要告知接收方，不过这个并不是放在TCP头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度
-   通过以上信息，接收方还能够检查收到的网络包有没有遗漏。
-   如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入TCP头部的ACK号中发送给发送方
-   在实际的通信中，序号并不是从1开始的，而是需要用随机数计算出一个初始值。因此需要在开始收发数据之前将初始值告知通信对象。
-   连接过程中，有一个将SYN控制位设为1并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。
-   数据双向传输时的情况：![image-20220513141530741](https://s2.loli.net/2022/05/13/Curka7HfyBlmd1q.png)
-   序号和ACK号的交互![image-20220513141558778](https://s2.loli.net/2022/05/13/ZquMpR1256igKAU.png)
-   TCP采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。
-   通过“序号”和“ACK号”可以确认接收方是否收到了网络包。

### 根据网络包平均往返时间调整ACK号等待时间

-   TCP采用了动态调整等待时间的方法，这个等待时间是根据ACK号返回所需的时间来判断的。
-   TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；相对地，如果ACK号马上就能返回，则相应缩短等待时间

### 使用窗口有效管理ACK号

滑动窗口，就是在发送一个包之后，不等待ACK号返回，而是直接发送后续的一系列包。这样一来，等待ACK号的这段时间就被有效利用起来了。

![image-20220513141939308](https://s2.loli.net/2022/05/13/EXQk3zRYF6UyHBs.png)

-   接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。
-   接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。
-   实际上和序号、ACK号一样，发送操作也是双向进行的。
-   ![image-20220513142147955](https://s2.loli.net/2022/05/13/FIUzaNH174G9kZR.png)

### ACK与窗口的合并

-   当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。
-   当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回ACK号
-   每收到一个包，就需要向发送方分别发送ACK号和窗口更新这两个单独的包。这样一来，接收方发给发送方的包就太多了，导致网络效率下降。

-   接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。

### 接收HTTP响应消息

-   浏览器在委托协议栈发送请求消息之后，会调用read程序来获取响应消息。然后，控制流程会通过read转移到协议栈，然后协议栈会执行接下来的操作。
-   接收数据也需要将数据暂存到接收缓冲区中
    -   协议栈尝试从接收缓冲区中取出数据并传递给应用程序，若响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起
    -   协议栈会检查收到的数据块和TCP头部的内容，判断是否有数据丢失，如果没有问题则返回ACK号。
    -   协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序。
-   协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新

## 从服务器断开并删除套接字

### 数据发送完毕后断开连接

-   协议栈在设计上允许任何一方先发起断开过程。
-   以服务器一方发起断开过程为例来进行讲解
    -   服务器一方的应用程序会调用Socket库的close程序。
    -   服务器的协议栈会生成包含断开信息的TCP头部，具体来说就是将控制位中的FIN比特设为1。
    -   协议栈会委托IP模块向客户端发送数据。同时，服务器的套接字中也会记录下断开操作的相关信息。
    -   当收到服务器发来的FIN为1的TCP头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态。
    -   为了告知服务器已收到FIN为1的包，客户端会向服务器返回一个ACK号。这些操作完成后，协议栈就可以等待应用程序来取数据了。
    -   应用程序就会调用read来读取数据。这时，协议栈不会向应用程序传递数据，而是会告知应用程序（浏览器）来自服务器的数据已经全部收到了。
    -   客户端应用程序会调用close来结束数据收发操作，这时客户端的协议栈也会和服务器一样，生成一个FIN比特为1的TCP包，然后委托IP模块发送给服务器
    -   一段时间之后，服务器就会返回ACK号
    -   ![image-20220513143533654](https://s2.loli.net/2022/05/13/S5YMCdfmAlJb72h.png)

### 删除套接字

-   套接字并不会立即被删除，而是会等待一段时间之后再被删除。等待这段时间是为了防止误操作
-   协议中对于这个等待时间没有明确的规定，一般来说会等待几分钟之后再删除套接字。

### 数据收发操作小结

1.   数据收发操作的第一步是创建套接字。
     1.   服务器一方的应用程序在启动时就会创建好套接字并进入等待连接的状态。
     2.   客户端则一般是在用户触发特定动作，需要访问服务器的时候创建套接字。
     3.   在这个阶段，还没有开始传输网络包。

2.   创建套接字之后，客户端会向服务器发起连接操作。
     1.   客户端会生成一个SYN为1的TCP包并发送给服务器。这个TCP包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小
     2.   当这个包到达服务器之后，服务器会返回一个SYN为1的TCP包。这个包的头部中也包含了序号和窗口大小，此外还包含表示确认已收到包①的ACK号
     3.   当这个包到达客户端时，客户端会向服务器返回一个包含表示确认的ACK号的TCP包。到这里，连接操作就完成了，双方进入数据收发阶段。![image-20220513144038302](https://s2.loli.net/2022/05/13/jpNVWSKHmIvZ71T.png)
3.   服务器的响应消息发送完毕之后，数据收发操作就结束了，这时就会开始执行断开操作。
     1.   以Web为例，服务器会先发起断开过程。在这个过程中，服务器先发送一个FIN为1的TCP包
     2.   客户端返回一个表示确认收到的ACK号
     3.   双方还会交换一组方向相反的FIN为1的TCP包和包含ACK号的TCP包
     4.   在等待一段时间后，套接字会被删除。

## IP与以太网的包收发操作

### 包的基本知识

TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成包发送给通信对象。

包的构成：

-   包是由头部和数据两部分构成
-   头部包含目的地址等控制信息
-   头部后面就是委托方要发送给对方的数据
-   ![image-20220515164515334](https://s2.loli.net/2022/05/15/WjJ18fDug4OLXok.png)

包的发送：

1.   发送方的网络设备会负责创建包。创建包的过程就是生成含有正确控制信息的头部，然后再附加上要发送的数据。
2.   接下来，包会被发往最近的网络转发设备。当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向。
3.   接下来，包在向目的地移动的过程中，又会到达下一个转发设备，然后又会按照同样的方式被发往下一个转发设备。
4.   经过多个转发设备的接力之后，包最终就会到达接收方的网络设备。
5.   ![image-20220515164743225](https://s2.loli.net/2022/05/15/JtEoK94eUP2wLzH.png)

不同的转发设备

-   路由器根据目标地址判断下一个路由器的位置。IP协议根据目标地址判断下一个IP转发设备的位置
-   集线器在子网中将网络包传输到下一个路由，子网中的以太网协议将包传输到下一个转发设备
-   集线器是按照以太网规则传输包的设备，而路由器是按照IP规则传输包的设备

IP网络包的传输方式：

![image-20220515165121361](https://s2.loli.net/2022/05/15/Ok6zM9TXxLsHZAj.png)
